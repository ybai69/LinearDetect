par(mar = c(4., 4.5, 1.5, 1))
qqnorm(Y_s, cex.lab=2, cex.axis=2, cex= 2, main=NULL)
qqline(Y_s, lwd = 3)
# dev.off()
qqnorm(X_s[,1])
qqline(X_s[,1])
qqnorm(X_s[,2])
qqline(X_s[,2])
p.x <- ncol(X_s)
p.y <- ncol(Y_s)
n <- nrow(X_s)
tol <- 10^(-4); # tolerance
max.iteration <- 200; # max number of iteration for the LASSO solution
method <- c("MLR")
if(sqrt(T-1) > p.x){
b_t.max <- round(min(sqrt(T-1), (T-1)/20))
}else{
b_t.max <- round(min(sqrt(T-1)*log(p.x), (T-1)/20))
}
b_t.min <- round(log(T-1)*log(p.x))
b_t.max
b_t.min
b_t.range <- round(seq(b_t.min, b_t.max, length.out = 5))
b_t.range
#p is the number of variables for each day (I_t and R_t)
p <- 2
#b_t is the block size among the time points (1 : (length(date) - 1))
#italy
if(country.name == "Italy"){
b_t <- 7
gamma.val <- 4.5
HBIC = TRUE
}else if(country.name %in% c("China", "Germany") ){
b_t <- 7
HBIC = FALSE
}else if(country.name %in% c("South Korea") ){
b_t <- 7
gamma.val <- 4
HBIC = TRUE
}else if(country.name %in% c("United States") ){
b_t <- 5
gamma.val <- 4
HBIC = TRUE
}else if(country.name %in% c("Australia") ){
b_t <- 7
gamma.val <- 1
HBIC = TRUE
}else{
b_t <- 7
HBIC = FALSE
}
b_n <- p * b_t
temp.1 <- tbfl(method, Y_s, X_s, lambda.1.cv = lambda.1, lambda.2.cv = 0,
max.iteration = max.iteration, tol = tol, HBIC = HBIC, gamma.val = gamma.val)
cp.final <- temp.1$cp.final
date.region[floor( (cp.final-1) / p) + 1]
temp.1$bn.optimal
temp.1$bn.range
######## Loading Datasets #######################
######## Country-level ###########################
# https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/L20LOT
cases.countries <- as.data.frame(read_excel("Countries-Confirmed.xlsx"))
deaths.countries <- as.data.frame(read_excel("Countries-Deaths.xlsx"))
recovered.countries <- as.data.frame(read_excel("Countries-Recovered.xlsx"))
date_lock <- read.table("Shelter_in_Place.csv", sep= ",", header = TRUE)
colnames(date_lock)
date_lock_sum <- apply(date_lock[,-c(1:4)], 2, sum)
date_lock_sum
colnames(date_lock[,-c(1:4)])[date_lock_sum == 0]
colnames(date_lock[,-c(1:4)])[which.max(date_lock_sum)]
plot(date_lock_sum)
date_reopen <- read.table("Shelter_in_Place_Reopen.csv", sep= ",", header = TRUE)
colnames(date_reopen)
date_reopen_sum <- apply(date_reopen[,-c(1:4)], 2, sum)
date_reopen_sum
colnames(date_reopen[,-c(1:4)])[date_reopen_sum == 0]
colnames(date_lock[,-c(1:4)])[which.max(date_lock_sum)]
colnames(date_reopen[,c(5:155)])[which.min(date_reopen_sum[1:150])]
plot(date_reopen_sum)
#########Change/choose the country name, lockdown date and reopen date below!!!!!!
# country.name <- "China"
# smooth.par = TRUE
# Date.start <- '2020-01-22'
# Date.1 <- '2020-01-23'
# Date.2 <- '2020-04-08'
country.name <- "Italy"
smooth.par = FALSE
Date.start <- '2020-01-31'
Date.1 <- '2020-03-09'
Date.2 <- '2020-05-18'
# country.name <- "Germany"
# smooth.par = FALSE
# Date.start <- '2020-01-27'
# Date.1 <- '2020-03-22'
# Date.2 <- '2020-05-01'
# country.name <- "Brazil"
# smooth.par = FALSE
# Date.start <- '2020-02-26'
# Date.1 <- '2020-03-24'
# #20 April: Several cities started to ease social isolation guidelines in favor of contact tracing.
# Date.2 <- '2020-04-20'
country.name <- "South Korea"
Date.start <- '2020-01-22'
smooth.par = TRUE
#There was no general lockdown of businesses in South Korea with supermarkets and other retailers remaining open. Kindergartens, schools, universities, cinemas, gyms were closed soon after the outbreak with schools and universities having online classes
Date.1 <- NULL
Date.2 <- NULL
#https://www.wired.co.uk/article/uk-lockdown
country.name <- "United Kingdom"
smooth.par = FALSE
Date.start <- '2020-01-31'
Date.1 <- '2020-03-23'
#confirming that pubs, restaurants and hotels can start reopening from 4 July.
Date.2 <- '2020-07-04'
#############################################
# lambda.1 <- NULL
# lambda.1 <- c( 5, 1, 0.5, 0.1, 0.05, 0.01, 0.005, 0.001)
# lambda.1 <- c(  1,  0.1,  0.01, 0.001)
lambda.1 <- c(1, 0.5, 0.1, 0.05, 0.01, 0.005, 0.001)
#################################################
#################construct the dataframe i
#T: number of time points
day.temp <- as.Date(Date.start) - as.Date('2020-01-22')
date.region <- as.Date(colnames(cases.countries)[-(1:(day.temp+1))], "%m%d")
cases.country <- t(cases.countries[(cases.countries$CNTRY_NAME == country.name), -(1:(day.temp+1))])
T <- nrow(cases.country)
deaths.country <- t(deaths.countries[(deaths.countries$CNTRY_NAME == country.name), -(1:(day.temp+1))])
recovered.country <- t(recovered.countries[(recovered.countries$CNTRY_NAME == country.name), -(1:(day.temp+1))])
#R: the number of people who have recovered
#using the nationwide recovered and death number to predict the recovered number
R <- deaths.country +  recovered.country
#I: the number of people infected at time t
I <- cases.country - R;
I_smooth <- I
I_smooth[I == Inf] = 0
I_smooth[-c(1:6)] <- rollmean(I_smooth, k = 7, align = 'right')
I_smooth[ c(1:6)] <- mean(I_smooth[ c(1:6)])
R_smooth <- R
R_smooth[R == Inf] = 0
R_smooth[-c(1:6)] <- rollmean(R_smooth, k = 7, align = 'right')
R_smooth[ c(1:6)] <- mean(R_smooth[ c(1:6)])
############################################
######## construct varibles ################
############################################
if(smooth.par == TRUE){
y.list <- vector("list", T-1);
x.list <- vector("list", T-1);
for(i in 2:T){
y.list[[i-1]] <- matrix(c(R_smooth[i]-R_smooth[i-1], I_smooth[i]-I_smooth[i-1]), 2, 1);
x.temp <- matrix(0, 2, 2);
x.temp[1,2] <- I_smooth[i-1];
x.temp[2,1] <-  I_smooth[i-1];
x.temp[2,2] <- -I_smooth[i-1];
x.list[[i-1]] <- x.temp;
}
Y <- y.list[[1]];
for(i in 2:(T-1)){
Y <- rbind(Y, y.list[[i]])
}
X <- x.list[[1]];
for(i in 2:(T-1)){
X <- rbind(X, x.list[[i]])
}
}else{
y.list <- vector("list",T-1);
x.list <- vector("list",T-1);
for(i in 2:T){
y.list[[i-1]] <- matrix(c(R[i]-R[i-1], I[i]-I[i-1]), 2, 1);
x.temp <- matrix(0, 2, 2);
x.temp[1,2] <- I[i-1];
x.temp[2,1] <-  I[i-1];
x.temp[2,2] <- -I[i-1];
x.list[[i-1]] <- x.temp;
}
Y <- y.list[[1]];
for(i in 2:(T-1)){
Y <- rbind(Y, y.list[[i]])
}
X <- x.list[[1]];
for(i in 2:(T-1)){
X <- rbind(X, x.list[[i]])
}
}
beta_t <- sapply(1:length(y.list), function(jjj)  (y.list[[jjj]][1]+y.list[[jjj]][2])/I[jjj])
gamma_t <- sapply(1:length(y.list), function(jjj)  y.list[[jjj]][1]/I[jjj])
cols <- c("dark orange", "purple", "darkolivegreen4", "blue" )
plot(date.region[-length(date.region)], beta_t,type='l',col=cols[1],lty=1,lwd = 3,
ylab ='Rate', xlab= 'Date',cex.lab=2 , cex.axis=2)
lines(date.region[-length(date.region)], gamma_t, col=cols[3],lty=1,type="l",lwd = 3)
plot(date.region[-length(date.region)], beta_t/gamma_t, ylim = c(0, 5),
type='l',col=cols[1],lty=1,lwd = 3,
ylab ='Rate', xlab= 'Date', cex.lab=2 , cex.axis=2 )
abline(v = as.Date(Date.1), col = 1,lwd = 2, lty = 3)
abline(v = as.Date(Date.2), col = 1,lwd = 2, lty = 3)
#################################################
######### Model 1  ##############################
#################################################
#scaling but not centering data
Y_std <- sd(Y)
Y_s <- scale(Y, center = FALSE, scale = apply(Y, 2, sd, na.rm = TRUE))
# plot(seq(1, length(Y_s),1),Y_s,type='l')
X_std <- apply(X, MARGIN=2, FUN=sd)
X_s <- scale(X, center = FALSE, scale = apply(X, 2, sd, na.rm = TRUE))
# plot(seq(1, dim(X_s)[1],1), X_s[,1],type='l')
# plot(seq(1, dim(X_s)[1],1), X_s[,2],type='l')
# filename <- paste0("qqplot_", country.name[1] ,".pdf")
# pdf(filename, width=11, height=8.5)
par(mar = c(4., 4.5, 1.5, 1))
qqnorm(Y_s, cex.lab=2, cex.axis=2, cex= 2, main=NULL)
qqline(Y_s, lwd = 3)
# dev.off()
qqnorm(X_s[,1])
qqline(X_s[,1])
qqnorm(X_s[,2])
qqline(X_s[,2])
p.x <- ncol(X_s)
p.y <- ncol(Y_s)
n <- nrow(X_s)
tol <- 10^(-4); # tolerance
max.iteration <- 200; # max number of iteration for the LASSO solution
method <- c("MLR")
if(sqrt(T-1) > p.x){
b_t.max <- round(min(sqrt(T-1), (T-1)/20))
}else{
b_t.max <- round(min(sqrt(T-1)*log(p.x), (T-1)/20))
}
b_t.min <- round(log(T-1)*log(p.x))
b_t.max
b_t.min
b_t.range <- round(seq(b_t.min, b_t.max, length.out = 5))
b_t.range
#p is the number of variables for each day (I_t and R_t)
p <- 2
#b_t is the block size among the time points (1 : (length(date) - 1))
#italy
if(country.name == "Italy"){
b_t <- 7
gamma.val <- 4.5
HBIC = TRUE
}else if(country.name %in% c("China", "Germany") ){
b_t <- 7
HBIC = FALSE
}else if(country.name %in% c("South Korea") ){
b_t <- 7
gamma.val <- 4
HBIC = TRUE
}else if(country.name %in% c("United States") ){
b_t <- 5
gamma.val <- 4
HBIC = TRUE
}else if(country.name %in% c("Australia") ){
b_t <- 7
gamma.val <- 1
HBIC = TRUE
}else{
b_t <- 7
HBIC = FALSE
}
b_n <- p * b_t
temp.1 <- tbfl(method, Y_s, X_s, lambda.1.cv = lambda.1, lambda.2.cv = 0,
max.iteration = max.iteration, tol = tol, HBIC = HBIC, gamma.val = gamma.val)
cp.final <- temp.1$cp.final
date.region[floor( (cp.final-1) / p) + 1]
temp.1$bn.optimal
temp.1$bn.range
# https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/L20LOT
cases.countries <- as.data.frame(read_excel("Countries-Confirmed.xlsx"))
deaths.countries <- as.data.frame(read_excel("Countries-Deaths.xlsx"))
recovered.countries <- as.data.frame(read_excel("Countries-Recovered.xlsx"))
date_lock <- read.table("Shelter_in_Place.csv", sep= ",", header = TRUE)
colnames(date_lock)
date_lock_sum <- apply(date_lock[,-c(1:4)], 2, sum)
date_lock_sum
colnames(date_lock[,-c(1:4)])[date_lock_sum == 0]
colnames(date_lock[,-c(1:4)])[which.max(date_lock_sum)]
plot(date_lock_sum)
date_reopen <- read.table("Shelter_in_Place_Reopen.csv", sep= ",", header = TRUE)
colnames(date_reopen)
date_reopen_sum <- apply(date_reopen[,-c(1:4)], 2, sum)
date_reopen_sum
colnames(date_reopen[,-c(1:4)])[date_reopen_sum == 0]
colnames(date_lock[,-c(1:4)])[which.max(date_lock_sum)]
colnames(date_reopen[,c(5:155)])[which.min(date_reopen_sum[1:150])]
plot(date_reopen_sum)
#########Change/choose the country name, lockdown date and reopen date below!!!!!!
# country.name <- "China"
# smooth.par = TRUE
# Date.start <- '2020-01-22'
# Date.1 <- '2020-01-23'
# Date.2 <- '2020-04-08'
country.name <- "Italy"
smooth.par = FALSE
Date.start <- '2020-01-31'
Date.1 <- '2020-03-09'
Date.2 <- '2020-05-18'
# country.name <- "Germany"
# smooth.par = FALSE
# Date.start <- '2020-01-27'
# Date.1 <- '2020-03-22'
# Date.2 <- '2020-05-01'
# country.name <- "Brazil"
# smooth.par = FALSE
# Date.start <- '2020-02-26'
# Date.1 <- '2020-03-24'
# #20 April: Several cities started to ease social isolation guidelines in favor of contact tracing.
# Date.2 <- '2020-04-20'
country.name <- "South Korea"
Date.start <- '2020-01-22'
smooth.par = TRUE
#There was no general lockdown of businesses in South Korea with supermarkets and other retailers remaining open. Kindergartens, schools, universities, cinemas, gyms were closed soon after the outbreak with schools and universities having online classes
Date.1 <- NULL
Date.2 <- NULL
#https://www.wired.co.uk/article/uk-lockdown
country.name <- "United Kingdom"
smooth.par = FALSE
Date.start <- '2020-01-31'
Date.1 <- '2020-03-23'
#confirming that pubs, restaurants and hotels can start reopening from 4 July.
Date.2 <- '2020-07-04'
country.name <- "United States"
smooth.par = FALSE
Date.start <- '2020-01-22'
# Date.1 <- c('2020-03-17', '2020-04-23')
# first state to  issues a stay at home order to last state: California to South carolian
Date.1 <- c('2020-03-15', '2020-04-07')
# colridao to new hampshire
#Sununu confirmed on June 11 that the stay-at-home order would expire on June 15
#Alaska first
# Date.2 <- c('2020-04-24', '2020-06-15')
Date.2 <- c('2020-04-24', '2020-06-28')
# country.name <- "Australia"
# smooth.par = TRUE
# Date.start <- '2020-01-26'
# #On 16 March, Victorian Premier Daniel Andrews declared a state of emergency until 13 April.
# #The State of Emergency was subsequently extended(see below).
# Date.1 <- '2020-03-16'
# Date.2 <- '2020-04-16'
#############################################
# lambda.1 <- NULL
# lambda.1 <- c( 5, 1, 0.5, 0.1, 0.05, 0.01, 0.005, 0.001)
# lambda.1 <- c(  1,  0.1,  0.01, 0.001)
lambda.1 <- c(1, 0.5, 0.1, 0.05, 0.01, 0.005, 0.001)
#################################################
#################construct the dataframe i
#T: number of time points
day.temp <- as.Date(Date.start) - as.Date('2020-01-22')
date.region <- as.Date(colnames(cases.countries)[-(1:(day.temp+1))], "%m%d")
cases.country <- t(cases.countries[(cases.countries$CNTRY_NAME == country.name), -(1:(day.temp+1))])
T <- nrow(cases.country)
deaths.country <- t(deaths.countries[(deaths.countries$CNTRY_NAME == country.name), -(1:(day.temp+1))])
recovered.country <- t(recovered.countries[(recovered.countries$CNTRY_NAME == country.name), -(1:(day.temp+1))])
#R: the number of people who have recovered
#using the nationwide recovered and death number to predict the recovered number
R <- deaths.country +  recovered.country
#I: the number of people infected at time t
I <- cases.country - R;
I_smooth <- I
I_smooth[I == Inf] = 0
I_smooth[-c(1:6)] <- rollmean(I_smooth, k = 7, align = 'right')
I_smooth[ c(1:6)] <- mean(I_smooth[ c(1:6)])
R_smooth <- R
R_smooth[R == Inf] = 0
R_smooth[-c(1:6)] <- rollmean(R_smooth, k = 7, align = 'right')
R_smooth[ c(1:6)] <- mean(R_smooth[ c(1:6)])
############################################
######## construct varibles ################
############################################
if(smooth.par == TRUE){
y.list <- vector("list", T-1);
x.list <- vector("list", T-1);
for(i in 2:T){
y.list[[i-1]] <- matrix(c(R_smooth[i]-R_smooth[i-1], I_smooth[i]-I_smooth[i-1]), 2, 1);
x.temp <- matrix(0, 2, 2);
x.temp[1,2] <- I_smooth[i-1];
x.temp[2,1] <-  I_smooth[i-1];
x.temp[2,2] <- -I_smooth[i-1];
x.list[[i-1]] <- x.temp;
}
Y <- y.list[[1]];
for(i in 2:(T-1)){
Y <- rbind(Y, y.list[[i]])
}
X <- x.list[[1]];
for(i in 2:(T-1)){
X <- rbind(X, x.list[[i]])
}
}else{
y.list <- vector("list",T-1);
x.list <- vector("list",T-1);
for(i in 2:T){
y.list[[i-1]] <- matrix(c(R[i]-R[i-1], I[i]-I[i-1]), 2, 1);
x.temp <- matrix(0, 2, 2);
x.temp[1,2] <- I[i-1];
x.temp[2,1] <-  I[i-1];
x.temp[2,2] <- -I[i-1];
x.list[[i-1]] <- x.temp;
}
Y <- y.list[[1]];
for(i in 2:(T-1)){
Y <- rbind(Y, y.list[[i]])
}
X <- x.list[[1]];
for(i in 2:(T-1)){
X <- rbind(X, x.list[[i]])
}
}
beta_t <- sapply(1:length(y.list), function(jjj)  (y.list[[jjj]][1]+y.list[[jjj]][2])/I[jjj])
gamma_t <- sapply(1:length(y.list), function(jjj)  y.list[[jjj]][1]/I[jjj])
cols <- c("dark orange", "purple", "darkolivegreen4", "blue" )
plot(date.region[-length(date.region)], beta_t,type='l',col=cols[1],lty=1,lwd = 3,
ylab ='Rate', xlab= 'Date',cex.lab=2 , cex.axis=2)
lines(date.region[-length(date.region)], gamma_t, col=cols[3],lty=1,type="l",lwd = 3)
plot(date.region[-length(date.region)], beta_t/gamma_t, ylim = c(0, 5),
type='l',col=cols[1],lty=1,lwd = 3,
ylab ='Rate', xlab= 'Date', cex.lab=2 , cex.axis=2 )
abline(v = as.Date(Date.1), col = 1,lwd = 2, lty = 3)
abline(v = as.Date(Date.2), col = 1,lwd = 2, lty = 3)
#################################################
######### Model 1  ##############################
#################################################
#scaling but not centering data
Y_std <- sd(Y)
Y_s <- scale(Y, center = FALSE, scale = apply(Y, 2, sd, na.rm = TRUE))
# plot(seq(1, length(Y_s),1),Y_s,type='l')
X_std <- apply(X, MARGIN=2, FUN=sd)
X_s <- scale(X, center = FALSE, scale = apply(X, 2, sd, na.rm = TRUE))
# plot(seq(1, dim(X_s)[1],1), X_s[,1],type='l')
# plot(seq(1, dim(X_s)[1],1), X_s[,2],type='l')
# filename <- paste0("qqplot_", country.name[1] ,".pdf")
# pdf(filename, width=11, height=8.5)
par(mar = c(4., 4.5, 1.5, 1))
qqnorm(Y_s, cex.lab=2, cex.axis=2, cex= 2, main=NULL)
qqline(Y_s, lwd = 3)
# dev.off()
qqnorm(X_s[,1])
qqline(X_s[,1])
qqnorm(X_s[,2])
qqline(X_s[,2])
p.x <- ncol(X_s)
p.y <- ncol(Y_s)
n <- nrow(X_s)
tol <- 10^(-4); # tolerance
max.iteration <- 200; # max number of iteration for the LASSO solution
method <- c("MLR")
if(sqrt(T-1) > p.x){
b_t.max <- round(min(sqrt(T-1), (T-1)/20))
}else{
b_t.max <- round(min(sqrt(T-1)*log(p.x), (T-1)/20))
}
b_t.min <- round(log(T-1)*log(p.x))
b_t.max
b_t.min
b_t.range <- round(seq(b_t.min, b_t.max, length.out = 5))
b_t.range
#p is the number of variables for each day (I_t and R_t)
p <- 2
#b_t is the block size among the time points (1 : (length(date) - 1))
#italy
if(country.name == "Italy"){
b_t <- 7
gamma.val <- 4.5
HBIC = TRUE
}else if(country.name %in% c("China", "Germany") ){
b_t <- 7
HBIC = FALSE
}else if(country.name %in% c("South Korea") ){
b_t <- 7
gamma.val <- 4
HBIC = TRUE
}else if(country.name %in% c("United States") ){
b_t <- 5
gamma.val <- 4
HBIC = TRUE
}else if(country.name %in% c("Australia") ){
b_t <- 7
gamma.val <- 1
HBIC = TRUE
}else{
b_t <- 7
HBIC = FALSE
}
b_n <- p * b_t
temp.1 <- tbfl(method, Y_s, X_s, lambda.1.cv = lambda.1, lambda.2.cv = 0,
max.iteration = max.iteration, tol = tol, HBIC = HBIC, gamma.val = gamma.val)
cp.final <- temp.1$cp.final
date.region[floor( (cp.final-1) / p) + 1]
temp.1$bn.optimal
temp.1$bn.range
beta_t_smooth <- beta_t
beta_t_smooth[beta_t == Inf] = 0
beta_t_smooth[-c(1:6)] <- rollmean(beta_t_smooth, k = 7, align = 'right')
beta_t_smooth[ c(1:6)] <- mean(beta_t_smooth[ c(1:6)])
gamma_t_smooth <- gamma_t
gamma_t_smooth[-c(1:6)] <- rollmean(gamma_t, k = 7, align = 'right')
gamma_t_smooth[ c(1:6)] <- mean(gamma_t[ c(1:6)])
ylim_max = 0.15
plot(date.region[-length(date.region)], beta_t_smooth, type = 'l', col = cols[1], lty = 1, lwd = 3,
ylab = 'Rate', xlab = 'Date',cex.lab = 2, cex.axis = 2, ylim = c(0, ylim_max))
lines(as.Date(date.region[-length(date.region)]), gamma_t_smooth,col = cols[3], lty=1, type = "l", lwd = 3)
cp.date <- date.region[floor( (cp.final-1) / p) + 1]
abline(v = as.Date(cp.date), col = "dark red",cex = 2 ,lwd = 2, lty = 2)
library(TBFLChangePointDetection)
library(TBFLChangePointDetection)
library(TBFLChangePointDetection)
?tbfl
library(TBFLChangePointDetection)
remove.packages("TBFLChangePointDetection")
library(TBFLChangePointDetection)
library(TBFLChangePointDetection)
tbfl()
tbfl
library(TBFLChangePointDetection)
